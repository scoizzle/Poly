using System.Collections.Frozen;

using Poly.Interpretation;
using Poly.Introspection;
using Poly.Introspection.CommonLanguageRuntime;

namespace Poly.DataModeling.Interpretation;

internal sealed class DataTypeDefinition : ITypeDefinition {
    private readonly DataType _dataType;
    private readonly Lazy<FrozenDictionary<string, DataTypeMember>> _members;
    private readonly string _name;
    private readonly ITypeDefinitionProvider _provider;

    public DataTypeDefinition(DataType dataType, ITypeDefinitionProvider provider)
    {
        _dataType = dataType ?? throw new ArgumentNullException(nameof(dataType));
        _name = dataType.Name;
        _provider = provider;
        _members = new(MemberDictionaryFactory);
    }

    public string Name => _name;
    public string? Namespace => null;
    public Type? ClrType => null; // Synthetic type - no CLR backing
    public IEnumerable<ITypeMember> Members => _members.Value.Values;
    public IEnumerable<ITypeField> Fields => Enumerable.Empty<ITypeField>();
    public IEnumerable<ITypeProperty> Properties => _members.Value.Values; // Assuming all members are properties
    public IEnumerable<ITypeMethod> Methods => Enumerable.Empty<ITypeMethod>();

    public bool TryGetMethod(string name, IEnumerable<Type> parameterTypes, out ITypeMethod? method)
    {
        method = null;
        return false;
    }

    public Type ReflectedType => typeof(IDictionary<string, object>);
    public ITypeDefinition? BaseType => null;
    public IEnumerable<ITypeDefinition> Interfaces => Enumerable.Empty<ITypeDefinition>();
    public IEnumerable<IParameter> GenericParameters => [];

    public bool IsArray => false;
    public bool IsNullable => true; // Data model properties can be null
    public bool IsNumeric => false; // Data types are complex objects, not numeric primitives
    public ITypeDefinition? ElementType => null;
    public ITypeDefinition? UnderlyingType => null; // Data types don't have underlying types

    private FrozenDictionary<string, DataTypeMember> MemberDictionaryFactory()
    {
        return _dataType
            .Properties
            .Select(e => new DataTypeMember(this, e, _provider))
            .ToFrozenDictionary(m => m.Name);
    }
}

internal sealed class DataTypeMember : ITypeProperty {
    private readonly DataTypeDefinition _declaring;
    private readonly DataProperty _property;
    private readonly Lazy<ITypeDefinition> _memberType;

    public DataTypeMember(DataTypeDefinition declaring, DataProperty property, ITypeDefinitionProvider provider)
    {
        _declaring = declaring ?? throw new ArgumentNullException(nameof(declaring));
        _property = property ?? throw new ArgumentNullException(nameof(property));
        _memberType = new Lazy<ITypeDefinition>(() => ResolveMemberType(property, provider));
        Name = property.Name;
    }

    public string Name { get; }
    public ITypeDefinition DeclaringType => _declaring;
    public ITypeDefinition MemberType => _memberType.Value;

    ITypeDefinition ITypeMember.MemberTypeDefinition => MemberType;
    ITypeDefinition ITypeMember.DeclaringTypeDefinition => DeclaringType;

    public IEnumerable<IParameter>? Parameters { get; }

    /// <summary>
    /// Data model properties are always instance members (not static).
    /// </summary>
    public bool IsStatic => false;

    public Value GetMemberAccessor(Value instance, params IEnumerable<Value>? _) => new DataModelPropertyAccessor(instance, Name, MemberType);

    private static ITypeDefinition ResolveMemberType(DataProperty property, ITypeDefinitionProvider provider)
    {
        var clr = ClrTypeDefinitionRegistry.Shared;

        if (property is ReferenceProperty refProp) {
            return provider.GetTypeDefinition(refProp.ReferencedTypeName) ?? clr.GetTypeDefinition<object>();
        }

        return property switch {
            StringProperty => clr.GetTypeDefinition<string>(),
            Int32Property => clr.GetTypeDefinition<int>(),
            Int64Property => clr.GetTypeDefinition<long>(),
            DoubleProperty => clr.GetTypeDefinition<double>(),
            BooleanProperty => clr.GetTypeDefinition<bool>(),
            GuidProperty => clr.GetTypeDefinition<Guid>(),
            DateTimeProperty => clr.GetTypeDefinition<DateTime>(),
            DateOnlyProperty => clr.GetTypeDefinition<DateOnly>(),
            TimeOnlyProperty => clr.GetTypeDefinition<TimeOnly>(),
            DecimalProperty => clr.GetTypeDefinition<decimal>(),
            ByteArrayProperty => clr.GetTypeDefinition<byte[]>(),
            JsonProperty => clr.GetTypeDefinition<object>(),
            EnumProperty => clr.GetTypeDefinition<string>(), // enums treated as strings by default here
            _ => clr.GetTypeDefinition<object>()
        };
    }
}